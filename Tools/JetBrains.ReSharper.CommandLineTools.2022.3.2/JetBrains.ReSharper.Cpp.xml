<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.ReSharper.Cpp</name>
    </assembly>
    <members>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.ClangTidy">
             <summary>
            	<para>
            		<para>ClangTidy Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.ClangTidy"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.ClangTidy.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                           pXqD##80BM        
                           pX--.'''BM        
                           pX--.'''BM        
                           pX--.'''BM        
                           pX--.'''BM        
                          ^pX--.'''BM/       
                         ?wT_--.'''^iWV      
                         4w``--.''''_W$      
                         4wpXqD##80BMW$      
                       ,Sp+  `````` .BX      
                    '*apT`  ```````  BB      
               "=LlP4|^`  ``.'````` -Bq      
               ek=_.    ```+{`````` *Bv      
               \4_      -=aP'````` _#8`      
                fh*` `^fOR{`     `+Dq'       
                 ~5wbpXOqRRRD###88qc`        
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PopetilThemedIconsThemedIcons+ClangTidy}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PopetilThemedIconsThemedIcons.ClangTidy))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PopetilThemedIconsThemedIcons.ClangTidy.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PopetilThemedIconsThemedIcons.ClangTidy&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.ClangTidy.Id">
            <inheritdoc cref="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.ClangTidy">identifier class</inheritdoc>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.ClangTidy.Load_Color">
            <summary>Loads the image for Themed Icon ClangTidy theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.ClangTidy.Load_Gray">
            <summary>Loads the image for Themed Icon ClangTidy theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.ClangTidy.Load_GrayDark">
            <summary>Loads the image for Themed Icon ClangTidy theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.ClangTidy.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon ClangTidy.</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Performance">
             <summary>
            	<para>
            		<para>Performance Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Performance"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Performance.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                  `_~*?T1Cf{)
                              -"\{C7L+=^^=;aa
                           ';slc;,__:,"~^=;P5
                   ``-'''^Jl+,''__:,"~^==;(PL
               `=c|?*\LLcL"'''__:~;^^==;;LPP`
              `zT'``':^===''__:+ePPPY!;+*Sh" 
               Tz``=llllv^__:,"}PPPPP?*LE4=  
               _vT'.+lFc,_:,"~^;zIj{J\?P4=   
                '{C_'___:,"~^==;;+*\L|6V~    
                cYL'__:,"~^==;;+*\LTSGv`     
               '=T5|=,"~^==;;+*\L?YhGv       
              `^,`:7E1+==;;+*\L725r*b7       
              =='-` 'zaYc+*\T}Y1Ya:\O+       
             '+^_'````:vVEj64j!::'_A4-       
             =\~::__:,""~c='_LEHe2pP.        
             *r+;^^:_-`         -_-          
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PopetilThemedIconsThemedIcons+Performance}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PopetilThemedIconsThemedIcons.Performance))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PopetilThemedIconsThemedIcons.Performance.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PopetilThemedIconsThemedIcons.Performance&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Performance.Id">
            <inheritdoc cref="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Performance">identifier class</inheritdoc>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Performance.Load_Color">
            <summary>Loads the image for Themed Icon Performance theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Performance.Load_Gray">
            <summary>Loads the image for Themed Icon Performance theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Performance.Load_GrayDark">
            <summary>Loads the image for Themed Icon Performance theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Performance.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon Performance.</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Unreal">
             <summary>
            	<para>
            		<para>Unreal Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Unreal"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Unreal.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                          .:;e*`             
                         :_I8-               
                         `:_6u`              
                  `*JVpX[?~^_rDTr[hpk}r.     
                `rDE;:.-~Th888847~-.:;2DT`   
                }D*```    ```````     `;De   
               ^mI```-c2j|:`````` ;*\ ``7m!  
              `6w:.. Ykkkkj .. :"--:: ..-Kb. 
              cb*---`-rsz?:`-- n3) .-----;bi 
             `XP:-----````----````.-------j4.
             !Xc:::::::~rJ2oooo2s?;:::::::\Xr
             {E;,,,,,\3E7~:-``'-^)kj*_,,,,"Ey
             /a7^^^=[j=.          `;2I\^^^Lac
              ~v55tT;`               ;){55s; 
                                             
                                             
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:WexuporThemedIconsThemedIcons+Unreal}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(WexuporThemedIconsThemedIcons.Unreal))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = WexuporThemedIconsThemedIcons.Unreal.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;WexuporThemedIconsThemedIcons.Unreal&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Unreal.Id">
            <inheritdoc cref="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Unreal">identifier class</inheritdoc>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Unreal.Load_Color">
            <summary>Loads the image for Themed Icon Unreal theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Unreal.Load_Gray">
            <summary>Loads the image for Themed Icon Unreal theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Unreal.Load_GrayDark">
            <summary>Loads the image for Themed Icon Unreal theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.Unreal.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon Unreal.</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.CppModule">
             <summary>
            	<para>
            		<para>CppModule Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.CppModule"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.CppModule.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
            
                    `._~!r)iii)r!~_.`
                  .,~;,'``````.-,~!r=,.
                .,,"-      ```..--,~/c;,.
              `.,;- "7|c,  ``.'-!xoy*-~c~.`
              -~_.` "iT);:-`.-^\Tuak*'~r!~-
              _r,`  ^l7|)c^`-_+1ueVh+'"/+r_
              "i^   ~tiTL+~_"~+JIVEX+-,=ri"
              "i~```={li+^!cT7?/JEh6r-"=ri"
              _r^..`=xFt;'/55ar_rKhX+-"!\r_
              -~^"_.!uI]!.=li7/"cEU6r-~r!~-
              `.^+=,r5oI!-~rr+!=TEU4?-=c~.`
                .,=r/==~==;!!!!!!!/+cT!,.
                  .,;LL?+/!;;;!/+?Lc!,.
                    `._~!r)iii)r!~_.`
            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:CppThemedIcons+CppModule}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(CppThemedIcons.CppModule))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = CppThemedIcons.CppModule.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;CppThemedIcons.CppModule&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.CppModule.Id">
            <inheritdoc cref="T:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.CppModule">identifier class</inheritdoc>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.CppModule.Load_SymbolsIdea">
            <summary>Loads the image for Themed Icon CppModule theme aspect SymbolsIdea.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.CppModule.Load_SymbolsVs08">
            <summary>Loads the image for Themed Icon CppModule theme aspect SymbolsVs08.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.CppModule.Load_SymbolsVs11Color">
            <summary>Loads the image for Themed Icon CppModule theme aspect SymbolsVs11Color.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.CppModule.Load_SymbolsVs11Gray">
            <summary>Loads the image for Themed Icon CppModule theme aspect SymbolsVs11Gray.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.CppModule.Load_SymbolsVs11GrayDark">
            <summary>Loads the image for Themed Icon CppModule theme aspect SymbolsVs11GrayDark.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resources.CppThemedIcons.CppModule.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon CppModule.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Util.CppMacroUtil.IsClosed(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            If subtree rooted at \p node contains any node from macro substitution then it should contain corresponding macro call
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Util.CastTo`1.From``1(``0)">
            This does not cause boxing for value types.
            Useful in generic methods.
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Util.CppDependentInfo.Uninitialized">
            This value can not be passed to any function expected CppDependentInfo,
            It's needed only for compact implementation of CppDependentInfoCachedValue
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Util.CppOverridenProjectFileProperties">
            Files having these properties will use the provided compilation flags directly, i.e.
            they will *not* get any extra flags from the project.
            
            These properties are only created in code and never loaded from VS solutions.
            See CppProjectSnapshot for examples.
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Util.CppOverridenProjectConfiguration.PROJECT_PROPERTIES_KEY">
            When present inside `VCXProjectConfiguration`, will be preferred over actual properties written inside it.
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassBuilder.SetUsedAsType">
            \pre must be called once
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.CppCtorInitializerStatementResolveEntityBase.GetResolvedTarget">
            could be ICppVariableDeclaratorResolveEntity for field or ICppClassResolveEntity/ICppDependentTypeResolveEntity for base
        </member>
        <!-- Badly formed XML comment ignored for member "F:JetBrains.ReSharper.Psi.Cpp.Symbols.CppEnumeratorResolveEntity.myPreviousEnumerator" -->
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.CppGenerateImplicitMembersUtil.GenerateImplicitlyGeneratedMembers(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppMutableClassResolveEntity)">
            @return \c false iff \code GeneratingImplicitMembersStatus() == CppGeneratigImplicitMembersStatus::None \endcode
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetDefinitionSymbol">
            CppLambdaClassResolveEntity returns \c null
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetAggregateMembers">
            \return sorted list of non-static fields and anonymous classes
            \note this function can be free and implemented using function \c GetChildren,
            but it requires additional allocation of list of class children
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.GetAllMembersSorted">
            \return all class members including constructors, destructors, finalizers and conversions
            \note this function can be free and implemented using function \c GetChildren and methods \c GetConstructors(), \c GetDestructors(), ...,
            but it requires additional allocation of list of class children
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasImmediateVirtualFunctions">
            \note this function can be free and implemented using function \c GetChildren and methods \c GetConversions(), \c GetDestructors(),
            but it requires additional allocation of list of class children
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.HasInheritingConstructors">
            \note this function can be free and implemented using function \c GetChildren ,
            but it requires additional allocation of list of class children
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity.ContainsSymbol(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassOrDelegateSymbolOrModuleEntity)">
            <remarks>
              this function can be free and implemented using property <c>SymbolParts</c>,
              but it requires additional allocation of list of symbols
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorResolveEntity.GetFirstDefaultArgIndex">
            @return int::MaxValue if `this` doesn't have default arguments
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.CppNamespacePendingActions.MergeActionsUpTo(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFileResolveEntitiesCache,JetBrains.ReSharper.Psi.Cpp.Symbols.ICppQualifiedNamePart,JetBrains.ReSharper.Psi.Cpp.Symbols.CppLocationAnchor)">
            \pre \p name != \code CppAnonymousId::INSTANCE \endcode
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Symbols.CppTemplateArgumentPackNonGenericBase">
            BASES /////////////////////////////////////////////////////////////////////////////////////////
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Symbols.CppTypeTemplateArgument">
            TYPE TEMPLATE ARGUMENT ////////////////////////////////////////////////////////////////////////
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Symbols.ICppExpressionTemplateArgument">
            EXPRESSION TEMPLATE ARGUMENT //////////////////////////////////////////////////////////////////
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateTemplateArgument">
            TEMPLATE TEMPLATE ARGUMENT //////////////////////////////////////////////////////////////////
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.CppClassResolveEntityWithSubstitutionClrImportedInstantiatedState.ChildByNameImpl(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppQualifiedNamePart)">
            @note must be called when \c ResolveMutex is locked
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.CppConceptDefinitionWithAppliedArgumentsResolveEntity.GetValue">
            \pre
            <code>!IsDependent(GetDependentInfo())</code>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.CppBitfieldSizeUtil.TryGetBitfieldSize(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppAttribute)">
            <remarks>
              May return <c>nullptr</c> if bitfield size presents complicated expression. Use overload if you need precise value
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.CppLinkageEntityUtil.IsTemplateClass(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppLinkageEntity)">
            Returns true if class is a template or a template substitution
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Symbols.CppResolveEntityUtil.IsAccessibleFrom(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppResolveEntity,JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity@,JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity,JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFriendDeclTargetResolveEntity,JetBrains.ReSharper.Psi.Cpp.Symbols.CppViewPos@)">
            @returns \c TriBool::Indeterminate iff \p ent is \c protected and EmbracingClass(\p scope) has dependent bases
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Doxygen.DoxygenSimpleListCommand">
            \brief \@li and \@arg commands
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppInclusionContextUtil.CalculateClrScope(JetBrains.ProjectModel.IProject,JetBrains.ReSharper.Psi.Modules.IPsiModule,JetBrains.ReSharper.Psi.Cpp.Caches.CppFileLocation)">
            \pre ClrCacheIsReady
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessor.CppMacroArgumentExpansionProcessor">
            Performs required processing during macro argument substitution into
            the macro body
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessor.CppMacroSubstitutionProcessor">
            Performs required processing during substitution of macro invokation
            with it actual replacement body
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessor.CppIfElifDirectiveProcessor">
            What does that?
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessor.CppIncludeDirectiveContentProcessor">
            Performs required processing during substitution of include directive body
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessor.EnumerateTokens">
            Word enumeration harness primarily (and solely, though) by word-index engine
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessor.myProcessingChain">
            Tip of the processing chain actual for the given `CppPreprocessor` instance;
            PP instances chaining extends this particular (processing) chain also
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessor.myScratchpad">
            Scratchpad instance; for detailed description see `CppPPScratchpad`
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessor.ITokenProcessor">
            `ITokenProcessor` -- abstracts the treatment of every (pre-)processed token before
            pushing it to the scratchpad; primary goal -- to provide facility for token processing,
            preserving ability to write-through them instantly reducing the count of the copy of a single
            particular token
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Parsing.Preprocessor.CppPreprocessor.CppPPScratchpad">
            `CppPPScratchpad` -- holy grail of the whole PP infrastructure; stores actual sequence of PREPROCESSED
            tokens; sharing this across `CppPreprocessor` instances allows to perform write-through pushes of
            preprocessed tokens, avoiding making of copies for every PP in the chain. Owned by the root `CppPreprocessor` instance.
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Parsing.CppDoxygenParsing.TryParseDoxygenSimpleList(JetBrains.Util.dataStructures.FrugalLocalList{JetBrains.ReSharper.Psi.Cpp.Doxygen.IPairedCommand}@)">
            Parse simple unnested lists (Commands \@arg and \@li)
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Parsing.CppDoxygenParsing.AdvanceToEnd(JetBrains.Util.dataStructures.FrugalLocalList{JetBrains.ReSharper.Psi.Cpp.Doxygen.IPairedCommand}@,System.Int32)">
            Advances until meets something that closes one of openCommands [or given number of newlines].
            NB: also does not advance through multiline comment postfix at the end of comment.
            \param openCommands stack of open paired doxygen Commands or HTML tags
            \param skipNewLineCount number of newlines allowed to skip. -1 stays for infinity.
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Parsing.CppDoxygenParsing.EatNewlineAndIndent(System.Int32)">
            eats newlines and whitespace after it
            \param newLineCount number of newlines to skip.
            Must be non-zero. Negative values
            \return indent of the current token
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Expressions.CppIsNoexceptUtil.HasExplicitNothrowDestructor(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity,JetBrains.ReSharper.Psi.Cpp.Symbols.CppViewPos@)">
            Check if the class has a destructor with an explicit and active noexcept specification.
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Lang.CppClionResolveEmulator.GetClionTypeOf(JetBrains.ReSharper.Psi.Cpp.Tree.ICppExpressionNode,JetBrains.ReSharper.Psi.Cpp.Util.CppTypeContext@,JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFileResolveEntitiesCache)">
            \pre IsTypeOrUnknownDependent(\p expr.GetDependentInfo())
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Lookup.CppCompletionResult.QualifierConstraints">
            concepts which qualifier of mem-access expressions satisfies, see test/data/CodeCompletion/Concepts06.cpp
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Lookup.CppViewPosUtil.ViewPosWhereClassIsComplete(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity)">
            this function can be used for such checks as
            - `IsDeleted` for special members;
            - `NeedImplicitDisposable` for class;
            - ...
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Overload.CppConversionHelper.TryFromStandardConversion(JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionInfo,JetBrains.ReSharper.Psi.Cpp.Types.CppQualType)">
            If a conversion exists, this routine will return the standard conversion sequence required to perform this
            conversion. Otherwise, this routine will return null.
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Overload.CppConversionHelper.DoOverloadResolutionForUserDefinedConversions(JetBrains.ReSharper.Psi.Cpp.Expressions.CppExpressionInfo,JetBrains.ReSharper.Psi.Cpp.Types.CppQualType,System.Boolean,System.Boolean,JetBrains.ReSharper.Psi.Cpp.Overload.CppImplicitConversionSequence@)">
             Determines whether there is a user-defined conversion sequence
             (C++ [over.ics.user]) that converts expression From to the type
             ToType. If such a conversion exists, User will contain the
             user-defined conversion sequence that performs such a conversion
             and this routine will return true. Otherwise, this routine returns
             false and User is unspecified.
            
             \param AllowExplicitConversions  true if the conversion should consider C++0x
             "explicit" conversion functions as well as non-explicit conversion
             functions (C++0x [class.conv.fct]p2).
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Overload.CppCompareConversionEngine.IsBetterImplicitConversion(JetBrains.ReSharper.Psi.Cpp.Overload.CppImplicitConversionSequence,JetBrains.ReSharper.Psi.Cpp.Overload.CppImplicitConversionSequence)">
            CompareImplicitConversionSequences - Compare two implicit
            conversion sequences to determine whether one is better than the
            other or if they are indistinguishable (C++ 13.3.3.2).
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppReferenceBindingInfo.IsDirectBinding">
            DirectBinding - True when this is a reference binding that is a
            direct binding (C++ [dcl.init.ref]).
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppReferenceBindingInfo.IsLvalueReference">
            \brief Whether this is an lvalue reference binding (otherwise, it's
            an rvalue reference binding).
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Overload.CppStandardConversionSequence">
            CppStandardConversionSequence - represents a standard conversion
            sequence (C++ 13.3.3.1.1). A standard conversion sequence
            contains between zero and three conversions. If a particular
            conversion is not needed, it will be set to the identity conversion
            (ICK_Identity). Note that the three conversions are
            specified as separate members (rather than in an array) so that
            we can keep the size of a standard conversion sequence to a
            single word.
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppStandardConversionSequence.First">
            First -- The first conversion can be an lvalue-to-rvalue
            conversion, array-to-pointer conversion, or
            function-to-pointer conversion.
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppStandardConversionSequence.Second">
            Second - The second conversion can be an integral promotion,
            floating point promotion, integral conversion, floating point
            conversion, floating-integral conversion, pointer conversion,
            pointer-to-member conversion, or boolean conversion.
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppStandardConversionSequence.Third">
            Third - The third conversion can be a qualification conversion.
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppStandardConversionSequence.IsDeprecatedCharPtrConv">
            \brief Whether this is the deprecated conversion of a
            string literal to a pointer to non-const character data
            (C++ 4.2p2).
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppStandardConversionSequence.SourceType">
            FromType - The type that this conversion is converting
            from.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Overload.CppUserDefinedConversionSequence">
            CppUserDefinedConversionSequence - Represents a user-defined
            conversion sequence (C++ 13.3.3.1.2).
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppUserDefinedConversionSequence.InitialConversion">
            \brief Represents the standard conversion that occurs before
            the actual user-defined conversion.
            
            C++11 13.3.3.1.2p1:
            If the user-defined conversion is specified by a constructor
            (12.3.1), the initial standard conversion sequence converts
            the source type to the type required by the argument of the
            constructor. If the user-defined conversion is specified by
            a conversion function (12.3.2), the initial standard
            conversion sequence converts the source type to the implicit
            object parameter of the conversion function.
            NOTE: As an extension we can also store User-defined conversion if conversion sequence is 
            created during direct-initialization.
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppUserDefinedConversionSequence.FinalConversion">
            After - Represents the standard conversion that occurs after
            the actual user-defined conversion.
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppUserDefinedConversionSequence.ConvertingFunction">
            ConvertingFunction - The function that will perform the
            user-defined conversion. Null if the conversion is an
            aggregate initialization from an initializer list.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Overload.CppAmbiguousConversionSequence">
            Represents an ambiguous user-defined conversion sequence.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Overload.CppBadConversionSequence">
            CppBadConversionSequence - Records information about an invalid
            conversion sequence.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Overload.CppImplicitConversionKind">
            CppImplicitConversionKind - The kind of implicit conversion used to
            convert an argument to a parameter's type. The enumerator values
            match with Table 9 of (C++ 13.3.3.1.1) and are listed such that
            better conversion kinds have smaller values.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCandidate">
            CppOverloadingCandidate - A single candidate in an overload set (C++ 13.3).
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCandidate.FailureKind">
            FailureKind - The reason why this candidate is not viable.
            Actually an OverloadFailureKind.
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCandidate.Conversions">
            Conversions - The conversion sequences used to convert the
            function arguments to the function parameters
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCandidate.Viable">
            Viable - True to indicate that this overload candidate is viable.
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCandidate.ExplicitCallArguments">
            \brief The number of call arguments that were explicitly provided,
            to be used while performing partial ordering of function templates.
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Overload.CppConversionFunctionOverloadingCandidate.FinalConversion">
            FinalConversion - For a conversion function (where Function is
            a CXXConversionDecl), the standard conversion that occurs
            after the call to the overload candidate to convert the result
            of calling the conversion function to the required type.
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCollectionBuilder.AddBuiltinOperatorCandidates(JetBrains.ReSharper.Psi.Cpp.CppSmallList{JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCandidate}@,JetBrains.ReSharper.Psi.Cpp.Symbols.CppOperatorKind,JetBrains.ReSharper.Psi.Cpp.Expressions.ICppExpression[])">
            AddBuiltinOperatorCandidates - Add the appropriate built-in
            operator overloads to the candidate set (C++ [over.built]), based
            on the operator @p Op and the arguments given. For example, if the
            operator is a binary '+', this routine might add "int
            operator+(int, int)" to cover integer addition.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCollectionBuilder.CppBuiltinCandidateTypeSet">
            BuiltinCandidateTypeSet - A set of types that will be used for the
            candidate operator functions for built-in operators (C++
            [over.built]). The types are separated into pointer types and
            enumeration types.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Overload.CppOverloadingCollectionBuilder.CppBuiltinOperatorOverloadBuilder">
            Helper class to manage the addition of builtin operator overload
            candidates. It provides shared state and utility methods used throughout
            the process, as well as a helper method to add each group of builtin
            operator overloads from the standard to a candidate set.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Presentation.CppPresenterUtil">
            <summary>
              Extensions for template arguments, parameters etc
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resolve.CppGroupedVariableDeclaratorResolveEntity.Create(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppVariableDeclaratorResolveEntity,JetBrains.ReSharper.Psi.Cpp.Resolve.ICppVariableTemplateDeclaratorResolveEntity)">
            checks and returns array or single
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resolve.DropDecorationsVisitor.AddDependencyOnPrimaryTemplate(JetBrains.ReSharper.Psi.Cpp.Symbols.CppUndeterminedSpecializationResolveEntity)">
            @returns \c null iff \p undeterminedSpecialization is not dependent on \c myPrimaryTemplate
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resolve.DropDecorationsVisitor.AddDependencyOnPrimaryTemplate(JetBrains.ReSharper.Psi.Cpp.Symbols.CppDependentResolveEntity)">
            @returns \c null iff \p depEnt is not dependent on \c myPrimaryTemplate
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resolve.DropDecorationsVisitor.AddDependencyOnPrimaryTemplate(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDependentTypeResolveEntity)">
            @returns \c null iff \p resolveEntity is not dependent on \c myPrimaryTemplate
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resolve.DropDecorationsVisitor.AddDependencyOnPrimaryTemplate(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTypeTemplateResolveEntity)">
            @returns \c null iff \p classTemplate is not dependent on \c myPrimaryTemplate
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resolve.DropDecorationsVisitor.VisitTemplateArguments(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppTemplateArgument[])">
            @returns \c null iff \p args is not dependent on \c myPrimaryTemplate
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.ReSharper.Psi.Cpp.Resolve.ICppDeductionGuide" -->
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resolve.ICppFunctionTemplateLikeDeducibleResolveEntity.PickSpecializationInSFINAEContext(JetBrains.ReSharper.Psi.Cpp.Util.CppTypeContext@,JetBrains.ReSharper.Psi.Cpp.Symbols.CppSubstitutionContext,JetBrains.ReSharper.Psi.Cpp.Overload.ICppTemplateFunctionCallDeductionErrorConsumer)">
            @returns \c null instead of declarator with type containing substitution failure
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Resolve.ICppGroupedFunctionDeclaratorResolveEntity.InstantiateFunctionBody(JetBrains.ReSharper.Psi.Cpp.Symbols.CppViewPos@,System.Boolean)">
            @return \c true iff function has body visible from \p vp and \p forceChameleonInstantiation == \c true or
            function really need body (functions with auto return type and constexpr functions)
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsUClass(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassSymbol)">
            Returns \c true if symbol marked by \c UCLASS
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsUStruct(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity)">
            Returns \c true if symbol marked by \c USTRUCT
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsUEnum(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity)">
            Returns \c true if entity marked by \c UENUM
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsUInterface(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity)">
            Returns \c true if entity marked by \c UINTERFACE
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsIInterface(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity)">
            Returns \c true if entity is IInterface (which means that it is named correctly and follows specially named entity marked by \c UINTERFACE)
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsUFunction(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorResolveEntity)">
            Returns \c true if entity marked by \c UFUNCTION
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsUFunction(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorResolveEntity)">
            Returns \c true if entity marked by \c UFUNCTION
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsUFunction(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorSymbol)">
            Returns \c true if symbol marked by \c UFUNCTION
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsUProperty(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorResolveEntity)">
            Returns \c true if entity marked by \c UPROPERTY
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsUProperty(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorSymbol)">
            Returns \c true if symbol marked by \c UPROPERTY
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsUClassMember(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppDeclaratorResolveEntity)">
            Returns \c true if entity is declared inside class marked by \c UCLASS
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsActor(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity,JetBrains.ReSharper.Psi.Cpp.Symbols.CppViewPos@)">
            Returns \c true if entity is related to some Actor class
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsComponent(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity,JetBrains.ReSharper.Psi.Cpp.Symbols.CppViewPos@)">
            Returns \c true if entity is related to some Component class
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsRpcFunction(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorResolveEntity)">
            Returns \c true if entity is an \c UFUNCTION with RPC specifiers (thus definition for this function and declaration of _Implementation method will be generated by UHT)
            @remarks Returns \c true also when entity is an \c UFUNCTION with \c BlueprintNativeEvent specifier!
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsRpcFunctionWithValidation(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorResolveEntity)">
            Returns \c true if entity is an \c UFUNCTION with RPC and \c WithValidation specifiers (thus declaration of _Validate method will be generated by UHT)
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsGeneratedRpcFunction(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorResolveEntity)">
            Returns \c true if entity is a function which has corresponding \c UFUNCTION with RPC specifier
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsBlueprintImplementableEventFunction(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorResolveEntity)">
            Returns \c true if entity is an \c UFUNCTION with \c BlueprintImplementableEvent specifier (thus definition for this function will be generated by UHT)
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.IsBlueprintCallableFunction(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorResolveEntity)">
            Returns \c true if entity is an \c UFUNCTION with \c BlueprintCallable specifier
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.CanContainUEMembers(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity)">
            Returns \c true if entity is related to UCLASS, USTRUCT or IINTERFACE
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.CanBeFinal(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity)">
            Returns \c true if making entity final won't break UnrealHeaderTool
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.FindPrototypeOfRpcCandidate(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorResolveEntity,JetBrains.ReSharper.Psi.Cpp.UE4.RpcWrapperType@)">
            Tries to find in class declaration of prototype function for specified RPC function
            @param rpcCandidate     target RPC function (for instance, \c ServerSomething_Validate)
            @param outCandidateType if \c rpcCandidate is indeed RPC function then returns its type. Otherwise - \c RpcWrapperType.None
            @returns \c nullptr if prototype function does not exist, otherwise - prototype \c UFUNCTION (for instance, \c ServerSomething)
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.FindGeneratedRpcFunction(JetBrains.ReSharper.Psi.Cpp.Resolve.CppGroupedFunctionDeclaratorResolveEntity,JetBrains.ReSharper.Psi.Cpp.UE4.RpcWrapperType)">
            Tries to find in class generated function for specified RPC \c UFUNCTION
            @param prototype    target RPC function
            @param targetType   generated function type to look for
            @returns \c nullptr if \c prototype \c UFUNCTION is invalid; valid resolve entity - otherwise
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.GetGeneratedRpcFunctionName(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorResolveEntity,JetBrains.ReSharper.Psi.Cpp.UE4.RpcWrapperType)">
            Returns name of generated function for specified RPC \c UFUNCTION
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.GetRelatedUInterface(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppClassResolveEntity,JetBrains.ReSharper.Psi.Cpp.Types.ICppResolvedTypeFactory)">
            Tries to find UInterface related to IInterface
            @param cent   IInterface class resolve entity
            @returns \c nullptr if UInterface does not exist, otherwise - UInterface resolve entity
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.TransformLinkageEntity(JetBrains.ReSharper.Psi.Cpp.Symbols.CppDeclaratorLinkageEntity,JetBrains.ReSharper.Psi.Cpp.Symbols.ICppFunctionDeclaratorResolveEntity,JetBrains.ReSharper.Psi.Cpp.UE4.RpcWrapperType,JetBrains.ReSharper.Psi.Cpp.UE4.RpcWrapperType,JetBrains.ReSharper.Psi.Cpp.Types.ICppResolvedTypeFactory)">
            Creates new linkage entity for corresponding RPC function
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.UE4.CppUE4Util.DeletedUE4Ctor">
            Schedules generation of RPC wrappers and Replication machinery if needed
            Schedules generation of event executor wrappers if needed
        </member>
        <!-- Badly formed XML comment ignored for member "P:JetBrains.ReSharper.Psi.Cpp.Tree.TemplateDeclaration.TemplateKeyword" -->
        <member name="P:JetBrains.ReSharper.Psi.Cpp.Tree.TryStatement.TryKeyword">
            Could be `try`, `_try` or `__try`
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.CppElementFactory.CreateNamespaceAliasDefinition(System.String,System.String)">
            namespace aliasName = namespaceName;
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Types.CppTypesUtil.GetReferenceRelation(JetBrains.ReSharper.Psi.Cpp.Types.CppQualType,JetBrains.ReSharper.Psi.Cpp.Types.CppQualType,JetBrains.ReSharper.Psi.Cpp.Util.CppTypeContext@,System.Boolean@)">
            CompareReferenceRelationship - Compare the two types T1 and T2 to
            determine whether they are reference-related,
            reference-compatible, reference-compatible with added
            qualification, or incompatible, for use in C++ initialization by
            reference (C++ [dcl.ref.init]p4). Neither type can be a reference
            type, and the first type (T1) is the pointee type of the reference
            type being initialized.
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Types.CppTypesUtil.NormalizeFunctionTypeForOverride(JetBrains.ReSharper.Psi.Cpp.Types.CppQualType,JetBrains.ReSharper.Psi.Cpp.Types.ICppResolvedTypeFactory)">
            <summary>
              Normalizes and discards calling convention
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Cpp.Types.CppReferenceRelation">
            CppReferenceRelation - Expresses the result of comparing two
            types (cv1 T1 and cv2 T2) to determine their compatibility for the
            purposes of initialization by reference (C++ [dcl.init.ref]p4).
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Types.CppReferenceRelation.Incompatible">
            Incompatible - The two types are incompatible, so direct
            reference binding is not possible.
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Types.CppReferenceRelation.Related">
            Related - The two types are reference-related, which means
            that their unqualified forms (T1 and T2) are either the same
            or T1 is a base class of T2.
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Types.CppReferenceRelation.CompatibleWithAddedQualification">
            CompatibleWithAddedQualification - The two types are
            reference-compatible with added qualification, meaning that
            they are reference-compatible and the qualifiers on T1 (cv1)
            are greater than the qualifiers on T2 (cv2).
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Cpp.Types.CppReferenceRelation.Compatible">
            Compatible - The two types are reference-compatible and
            have equivalent qualifiers (cv1 == cv2).
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.Types.ICppResolveCache.TryGetCachedType(JetBrains.ReSharper.Psi.Cpp.Symbols.ICppRawDeclaratorResolveEntity)">
            @return CppQualType::NullType() if there is no cached type for @p key
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Cpp.CppSmallEnumerable`1.GetRaw">
            Implementation detail
        </member>
    </members>
</doc>
